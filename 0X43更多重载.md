# 0X43更多重载

## 前置知识

* 0X42重载运算

## 正文

### 其他算符

重载其他的算符就像重载加法一样,只不过索引使用`'__add'`,而是使用其他的对应索引.

注意,定义的函数要和要重载的运算目数相当.

| 索引 | 作用 |
| ---- | ---- |
| __add | 加法运算 |
| __sub | 减法运算(减号作二目运算) |
| __mul | 乘法运算 |
| __div | 除法运算 |
| __mod | 取模运算 |
| __pow | 乘方运算 |
| __unm | 取反运算(减号作一目运算) |
| __idiv | 整除运算 |
| __band | 按位与运算 |
| __bor | 按位或运算 |
| __bxor | 按位异或运算 |
| __bnot | 按位非运算 |
| __shl | 左移运算 |
| __shr | 右移运算 |
| __concat | 链接运算(两个句点) |
| __len | 取长度运算 |
| __eq | 相等判断 |
| __lt | 小于判断 |
| __le | 小于等于判断 |

### 重载查表

在查表时,如果没有对应的元素但是这个表有元表.Lua就会进一步在它的元表中的`'__index'`这一项当中去查表.典型的例子是string类的值的默认元表的`'__index'`项是一个包含有之前我们介绍的用于字符串处理的函数的表.所以我们之前介绍的字符串处理函数也可以用面向对象的风格调用.实验:

>```lua
>l=getmetatable('1234')
>for i,v in pairs(l.__index) do print(i,v) end
>```

除了获取表成员可以重载,设置表的新成员这一事件也可以重载.其对应的标签是`'__newindex'`.给一个表中不存在的索引复制时,就会调用这个方法(用等式赋值的方法,创建新的表成员的时候).

>```lua
>f=function (x,y,z) print("can't add new index") end
>t={__newindex=f}
>x={}
>x[123]='eee'
>print(x[123])
>```

这里重载之后实际上每次新增成员都会输出一句话,而不会新增成员.

注意,`'__newindex'`对应的方法可以接受三个参数,按顺序是:表本身,要新增的索引(键),要新增的值.

另外,`'__index'`对应的也可以是一个函数,这个函数调用时将被传递给两个参数--表和索引.

`'__newindex'`对应的也可以是一个表,这样所有给表本身新增的成员都会新增到其元表中对应`'__newindex'`的表中.

### 重载调用

如果`'__call'`有一个函数调用.那么即使表也可以用于函数调用表达式.调用结果就是把表本身和调用表达式中的参数参数传递给`'__call'`对应的函数,然后获取返回值.

例如:

>```lua
>t={__call=print}
>x={}
>setmetatable(x,t)
>x('hello')
>```

### 重载元表操作

如果一个表的元表中有`'__metatable'`键,则getmetatable会返回这项对应的值.给这样的表设置元表也会引起错误.

## 后续推荐

* 0X44垃圾回收