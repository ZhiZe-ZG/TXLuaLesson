# 0X41动态脚本

## 前置知识

* 0X40读取文件

## 正文

### 构建自我

Lua的脚本就是一个普通的文本,Lua又有编辑文本的能力.如果Lua能轻松地调用执行别的Lua脚本文件,它就有了自我复制,自我修改的能力.之前我们已经介绍了如何编写模块,这里我们介绍一种更直接的方法.

dofile函数接受一个字符串作为参数(表示文件名),表示把目标文件当作Lua脚本执行.并且把脚本执行的返回值作为自己的返回值返回.例如

>```lua
>x=dofile('hello.lua')
>```

### 装载(编译)

如果你仅仅希望把脚本装载,在需要的时候再执行.就可以使用load和loadfile函数.

load函数最多接受四个参数:chunk,chunkname,mode,env.其中后三个为可选.

chunk为必选,它是一个字符串.load函数把这个字符串当作脚本装载,并返回一个函数.以后执行这个函数就相当于执行chunk中的命令.例如:

>```lua
>y=load('print("hello"')
>y()
>```

默认load的chunk都是匿名的.这回在调试的时候带来麻烦(比如显示错误信息的时候).所以可以通过chunkname(这是一个字符串)给它指定一个名字.

mode也是一个字符串,它有三种可能:仅二进制'b',仅文本't',二进制或文本'bt'.这个会涉及Lua的编译原理,现在只需要知道默认是'bt'.

参数env用于设置环境变量,目前不需要操作这个参数.

loadfile函数类似于load.但是它不接受chunk和chunkname,而是接受filename.它把指定文件装载为一个函数.

### 反向转换

在Lua中可以执行的函数都有其二进制形式.我们可以使用string.dump函数将其二进制形式的代码转化成字符串(只是简单的数据拷贝,不是逆编译).当作普通的字符串进行传递.

传递到目标之后再使用load装载,然后就可以执行了.例如:

>```lua
>f=function (x) return x*x end
>strf=string.dump(f)
>y=load(strf)
>y(12)
>```

string.dump还有一个可选参数,如果可选参数为true,则不会把debug信息和实现函数代码的功能一同dump出来.

## 后续推荐

* 0X42重载运算
* 0X45错误处理
* 0X47同时执行