# 0X23计数工具

## 前置知识

* 0X1E闭包

## 正文

1. 假设我们需要这样的一种工具,它能保存我们使用它的次数.每使用一次,它就加一.如果你已经学过循环相关的内容,应该能察觉,控制循环次数的循环变量就起着这样的作用.
1. 现在利用闭包机制实现一个这样的工具.
    >```lua
    >function creater()
    >    local x=0
    >    function timer()
    >        x=x+1
    >        print(x)
    >    end
    >    return timer
    >```
1. 使用方法是先调用creater函数,其返回值就是一个计数器.每调用计数器一次,就会输出一个比上次多1的结果.而且creater多次嗲用,会返回多个互不干扰的计时器.
    >```lua
    >a=creater()
    >a()
    >a()
    >b=creater()
    >a()
    >b()
    >b()
    >a()
    >```
1. 现在来说明一下这个工具的定义.首先在creater内部定义了两个变量.一个是x一个是函数timer.
    * 其中的变量x是局部变量.
    * 由于timer的定义在函数creater内部.所以在函数timer中可以访问creater中的局部变量x.
    * 当调用一次creater时.它首先得到内存空间用以存储x和timer.
    * 然后它以timer作为返回值,所以timer在creater运行结束之后仍然可以被调用.其内存不会被回收.
    * 由于timer不会被回收,而它又要访问x.所以x的内存也不会被回收.
    * 又由于x不是timer的局部变量.不会随着timer的每次运行结束而被清空重置.所以timer对它的修改得以表流下来.
1. 那么为什么creater的两次的返回结果a和b的计数是相互独立的呢?
    * 因为函数每次调用都要占用一块新的内存空间存储变量.
    * 一次运行结束后,即使内存由于种种原因没有被回收.函数再次调用时也会开辟一块完全不同的新内存空间.
1. 这里的代码其实有一点小问题.就是timer函数并不是creater内部的局部变量.所以在creater函数定义外直接使用"timer()"可以调用creater最后一次运行所创建的计时器.
    * 如果希望a,b这些计时器名是嗲用计时器的唯一方法,应该在creater内部把timer函数声明为creater的局部变量.例如"local function timer()"
1. 演示: 计数工具 <https://www.bilibili.com/video/av16161045/>
1. 虽然这个计数工具的实现基于函数式编程的闭包特性,但是这种用法却是违背函数式编程的一些原则的.例如函数式编程中,以相同的参数调用两次同一个函数,返回的结果应该是完全一致的.
1. local关键字也可以用于函数定义之前.这样函数定义自动创建的变量名(函数名)就会是局部变量.

## 后续推荐

* 0X2F函数和表
