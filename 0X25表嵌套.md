# 0X25表嵌套
## 前置知识
* 0X24词典
## 正文
1. Lua并没有直接提供class等关键字用于支持面向对象编程.但是依靠Lua函数和表的特性我们仍旧可以写出面向对象的程序.
2. 为了不让人感觉突兀.Lua提供了一些语法糖,用于使得一些写法与C++,C#,Java等传统的面向对象语言相一致.这些语法糖只是现有语言特性的另一种写法,而并不是提供了新的特性.
3. 当表的元素的索引是字符串时,我们可以省略掉方括号,以及标记字符串边界的引号.而使用句点"."链接表名和索引内容.例如:
    >```
    >L={}
    >L.firstname="Tai"
    >L.lastname="Xuan"
    >print(L.firstname,L.lastname)
    >```
    上边的代码其实等价于:
    >```
    >L={}
    >L['firstname']="Tai"
    >L['lastname']="Xuan"
    >print(L['firstname'],L['lastname'])
    >```
    虽然用了语法糖的写法,看起来就像在调用L的对象属性,但是对Lua来说,这本质上是在查表.
4. 把函数用语法糖调用,感觉就像是在用类方法.
    >```
    >L={}
    >L.p=print
    >L.p("This is a method.")
    >```
5. 在面向对象编程中,我们经常会通过方法修改对象本身的属性.这对于Lua也成立.
## 后续推荐


3. 表也可以作为表的成员.如果表的成员本身也是表,就可能出现连续使用多个方括号多次索引.例如:
    >```
    >L1={'hello','world','good'}
    >L2={23,34,L1}
    >print(L2[3][2])
    >```
    在输出时,L2先和[3]结合.返回值是L1的值.它仍是一个表,继续和[2]结合.返回的值就是'world'.
4. 一个表也可以是自己的成员,由于定义这个表的时候它本身的变量名还没有被赋值.所以把自己变成自己的成员这个过程需要一个中间步骤.
    >```
    >L={12,34}
    >L[3]=L
    >print(L[3][3][1])
    >L[3][3][3]==L
    >```
5. 如果不涉及自我包含.表的嵌套可以一次性定义出来.
    >```
    >L={12,34,{222,333,3334},83}
    >print(L[3][1])
    >```
6.  特别注意.在表作为表的成员时.并没有把作为成员的表复制一份.而是只保存了一个引用.(这很好理解,如果一个表作为另一个表的成员就复制一份的话.一个包含自己的表会瞬间耗尽任意大的内存.)
7. 关于6中提到的问题.更正式的说法是Lua中的表是引用类型.这涉及内存分配的问题.我不想在此展开讨论.如果你已经了解过引用类型和值类型的区别.那么在Lua中,把所有类型都当做引用类型处理就行了.因为把值类型当作对常量的引用就好了.
8. 引用类型的一个很直观的体现就是,在修改作为成员的表的内容的时候.如果通过把这个表当作成员的表访问,查看到的也是修改后的结果.例如:
    >```
    >L1={3,4,5}
    >L2={8,L1,9}
    >print(L2[2][1])
    >L1[1]='I  am changed'
    >print(L2[2][1])
    >```
9. 那么如果我希望得到一个链表的复制品(修改一个时候不会影响另一个).就需要创建一个新的表,然后把前者的数据都复制过来.例如:
    >```
    >LL1={4,5,6}
    >LL2={}
    >LL2[1],LL2[2],LL2[3]=LL1[1],LL1[2],LL1[3]
    >print(LL2[1],LL2[2],LL2[3])
    >LL1[2]='Changed'
    >print(LL1[2])
    >print(LL2[2])
    >```
10. 在9中举例的方法.如果结合了结构控制中的循环语句 .就能实现对任意成员个数的表实现复制.但是这还是没有办法解决嵌套表的复制问题.例如:
    >```
    >L={1,2,3}
    >L1={8,L}
    >L2={}
    >L2[1],L2[2]=L1[1],L1[2]
    >L1[2][3]='Changed'
    >print(L1[2][3])
    >print(L2[2][3])
    >````
    可以看到L1和L2中的第二个元素的第三个元素同时被改变了.
11. 解决嵌套表的复制问题.可以结合值类型判断使用递归算法.在复制一个表时如果它的成员仍旧是表,则对这个成员也递归使用复制函数.不过这些算法层面的问题和具体的语言关系不大,我将在别的教程中详细讨论.