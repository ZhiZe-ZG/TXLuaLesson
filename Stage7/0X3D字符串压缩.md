# 0X3D 字符串压缩

## 前置知识

* 0X32 模块搜寻

## 正文

### 压缩目的

字符串压缩虽然返回值是字符串,但是却不是以ASCII的格式写入的字符串.它是Lua提供的又一种操作底层数据(字节层面)的方法.它实际上是按各种约定(整数,无符号整数,浮点数,ASCII等)把不同类型的值转化为对应的字节串.又因为恰好Lua中的字符串是以字节为单位的数据结构.这些字节串也可以使用Lua的字符串操作.

### 压缩字符串

string.pack的第一个参数叫fmt,它的作用类似于正则表达式中的模式用于指定压缩格式.在fmt之后可以接受任意个参数,这些参数称为值.这个函数的作用就是依据fmt的格式把后边的值压缩到一个字符串中.例如:

>```lua
>str=string.pack('Jdb',120,120,120)
>print(str)
>```

输出的字符串是不认识的乱码很正常.因为这里的pack生成的数据虽然是以字符串形式返回.但是,却不是按照ASCII编码压缩的.例如fmt中的第一个字母J会被第一个参数120取代.而J代表把取代它的数按无符号整数类型格式写入字节.

这里说明一下,fmt中的字母会被后续的一个值替换,替换后,值要按照fmt中字母表示的格式进行转换,然后写入字节.

如果要查看按照指定模板打包压缩后的字符串的长度,使用string.packsize函数.参数是压缩格式fmt.返回值的单位是字节.

### 解压

string.unpack函数用于解压字符串.它接受压缩模板和被压缩的数据作为参数.把解压后的数据逐个返回.例如对之前压缩的字符串使用:

>```lua
>print(string.unpack('Jbd',str))
>```

这个函数返回的最后一个值是按照fmt解压之后,str字符串中的下一个字节在str中的位置.举个例子,`string.packsize('Jdb')`是18(这个格式的大小是18个字节).从str的1位置开始读取18个字节后,19作为最后一个返回值返回.

如果想让解压函数不从str的第一个字节开始读取,就给一个额外参数表示从第几个字节开始解压.例如:

>```lua
>str=string.pack('Jdb',120,120,120)
>print(string.unpack('db',str,string.packsize('J')+1))
>```


### 压缩格式

类似`'J'`表示压缩一个值为无符号整数,类似的还有很多别的占位符.这里所说的所有变量类型(如果不加说明)都是指C语言中的:

| 表达式 | 意义 |
| ---- | ---- |
| b | char型有符号整数 |
| B | char型无符号整数 |
| h | short型有符号整数 |
| H | short型无符号整数 |
| l | long型有符号整数 |
| L | long型无符号整数 |
| T | size_t型(大于等于地址线宽度) |
| f | 浮点型 |
| d | 双精度浮点型 |
| j | lua_Integer型 |
| J | lua_Unsigned型 |
| n | lua_Number型 |
| in | n处写一个整数,表示n字节整数 |
| In | n处写一个整数,表示n字节无符号整数 |
| cn | n处写一个整数,表示固定n个字节长度的字符串 |
| sn | n处写一个整数.这是一个打包了长度信息的字符串.长度信息会以n字节无符号整数的形式保存在压缩后字节的开头. |
| z | 一个以0为结尾的字符串 |

对于选项'in','In','sn'(以及后续介绍的'!n'),n可以是1到16间的整数.所有的整数选项都将做溢出检查.

### 格式设置

在使用多字节整数的时候,有两种格式--大端和小端.他们两者的高低字节的顺序是反的.可以在fmt开始处加入设置字符进行修改.`'<'`表示小端,`'>'`表示大端,`'='`表示使用默认.例如:

>```lua
>string.pack('<hhh',11121,11121,11121)
>string.pack('>hhh',11121,11121,11121)
>```

有时候我们可能需要对齐压缩后的字符串.这时可以用`'x'`进行占位.它会占用一个字节但是,不用任何数据填充.

在一开头使用感叹号加一个整数,可以设置自动填充,例如:

>```lua
>string.packsize('!2bh')
>string.packsize('bh')
>```

第一句中要求把不足2字节的对齐到2字节,会补充一个空字节.所以会多占用一位.

另外有一个对齐选项X,它后边可以跟一种fmt中用到的字母.它的作用类似于打字时候的tab键.它表示补充对齐到指定的类型(X后跟的类型).例如:

>```lua
>string.packsize('!8bXfb')
>```

其长度为5.首先第一个b占用1字节,Xf表示按照f对齐.f是4字节,所以在b后再补充3个空字节,补充到4.然后第二个b又占一个字节.

这里说一下为什么开头一定要设置最大补齐为8.如果不设置,则默认最大补齐长度为1.也就是不补齐,所有的大写X都会失效.

注意,在使用各种对齐和长度参数的时候尽量用2的次方.

## 后续推荐

暂无
