# 0X27跳转语句

## 前置知识

* 0X26条件表达式

## 正文

1. 这次介绍的语句名为"跳转语句".一般来说Lua的脚本是顺序执行的.遇到选择分支结构,会从其分支中选择一个执行.而执行到跳转语句的时候,它会打断程序的顺序执行,而是跳到之前或者之后某一句然后开始执行.
1. 跳转语句也可以跳转到其本身执行.但是那样的话,就永远执行体哦转到自己这一句.从而无法执行其他语句.这称为"死循环".
1. 在说跳转之前,我们需要先了解一些辅助的语句.
1. 首先是do-end语句.
    * 如果不使用任何流程控制结构(例如if语句,while循环,for循环,跳转语句等),Lua的脚本是默认顺序执行的.
    * 但是Lua还是添加了一个与这些流程控制结构相对应的语句do-end语句.表示在关键词do和end之间包括起来的内容顺序执行.这种语句加和不加都不影响程序的执行顺序.
    * do-end语句的意义在于,它把多个相互独立的语句变成了一整个复合语句.(就像if中,每个分支中的代码都可以是若干个独立的语句).
    * 另外在交互式环境中.只有当do-end的最后一个end输入完成,do-end之间包括的代码(代码块),才会开始执行.而不像输入很多独立的句子那样.写一句,执行一句.
    * 在交互式环境中演示goto时我将把整段代码放在do-end之间.因为如果不这样做,交互式编程环境会自动清除跳转标签.如果你已经学过写Lua脚本文件.则可以在脚本中练习本节内容.而且不需要给代码套上do-end.
1. 然后是label语句.它的作用是把一行代码进行标记.标记名的要求和变量名一样.但是这个名字并不代表一个变量(或者说一个内存空间),而是表示程序中的一个位置.它的写法是用一对双冒号把标签名扩起来:
    >```lua
    >::mark1::
    >```
1. 如果已经学过脚本相关的章节请注意.标签语句只要在脚本里就生效.不需要执行.
1. 最后是我们的重头戏goto语句.goto语句就是关键词goto后接标签名.这个语句一旦执行,程序执行就会从当前位置跳转到标签位置.尝试以下代码:
    >```lua
    >do
    >    goto mark2
    >    ::mark1::
    >    print('This is mark1')
    >    ::mark2::
    >    print('This is mark2')
    >end
    >```
    这里第一个print语句被跳过.直接执行了第二个语句.
1. goto配合条件判断(if语句)可以实现分支结构.但由于Lua中本身就提供了if分支,所以这个用途不是很明显.但是如果goto跳转到的标签在goto本身之前,则会产生另一种基本的流程控制结构:循环.
1. 首先来看一个例子:
    >```lua
    >do
    >    i=0
    >    ::mark::
    >    print(i)
    >    i=i+1
    >    goto mark
    >end
    >```
    这个循环会从1,2,3开始数并且一数下去.它反复地执行标签mark到goto语句之间的内容(包括goto语句本身).如果不出现手动终止,内存耗尽或者溢出之类的情况它不会自己终止.所以称之为"死循环".现在要终止输出,使用快捷键C-c(ctrl加c).
1. 要控制循环次数只需要给goto加上条件判断:
    >```lua
    >do
    >    i=0
    >    ::mark::
    >    print(i)
    >    i=i+1
    >   if i<100 then  goto mark end
    >end
    >```
1. Lua的goto语句,和C语言中的goto语句,都有很深的汇编语言的印记.它们就是汇编语言中无条件跳转语句的翻版.
    * 在汇编语言中,仅仅使用条件跳转(逻辑上相当Lua的if加goto)和无条件跳转就能实现所有的流程控制.
    * 使用跳转完成流程控制是一种非常典型的面向过程的程序风格.
    * 这一节介绍goto语句主要是为了说明流程控制的底层实现思路.并不推荐在Lua程序中使用goto语句(虽然Lua提供了这种语句).
    * 不推荐使用goto语句的原因有很多.最主要的就是使用它违反了高内聚低耦合的原则.并且可能因为考虑不周造成很多意想不到的错误.
1. Lua的goto语句比起C来要安全一些(具体详见官方文档),但是仍然不建议在面向对象或者函数式编程中使用.

## 后续推荐

暂无