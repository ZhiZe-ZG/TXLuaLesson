# 0X31模块编写

## 前置知识

* 0X30模块调用

## 正文

### 1. 回顾脚本

回顾之前在脚本编写上的内容.脚本需要在命令行中直接指定运行.但是当程序比较大的时候,把所有代码都放到一个文件中就会难以管理和编辑.需要把程序分割成很多个相对独立的部分进行管理.

另外,在编写程序时有很多通用的代码(例如在一个程序的很多部分中或者很多程序中都能用到的函数).我们希望把这些通用性的代码可以独立编写成一个文件在需要的时候进行调用.

### 2. 模块脚本

在Lua中通过模块来实现之前讨论的功能.模块是一种不需要直接从命令行执行的脚本.一般来说,这种脚本中会定义一个表.在脚本中给这个表增加各种成员.在脚本的最后利用return语句把这个表返回.这个表就是在模块调用语句返回的表.

关于return语句请注意,这个return语句不包含在任何的代码块(函数定义,流程控制复合句)之中.(从整体上看,一个脚本也就相当于一个特别大的函数.)

在模块脚本所在的位置打开Lua虚拟机.然后使用模块调用函数require调用刚刚编写好的模块.模块脚本文件的名称(不包括后缀".lua")就是模块的名称.

演示: 模块的编写和调用 <https://www.bilibili.com/video/av16792692/>

注意,一般来说模块脚本的文件名(不包括后缀".lua"的部分),模块脚本中的表的名称应当一致.

### 3. package模块

package模块是一个Lua标准库中的模块.如果这个模块的内容不能正常使用,请先执行

>```lua
>require('package')
>```

package.loaded是一张表.其成员是所有已经加载的模块.在require函数执行时,如果发现loaded中有同名成员,则require不再执行模块脚本,而是直接返回loaded中的对应值.

与package.loaded类似的有一个package.preloaded表.require也会先查询它,如果在其中找到同名成员,就把这个成员作为require的结果返回.但是这个表中一般都是存放特殊的预加载模块.一般不涉及这个表的使用.

一般来说模块脚本中定义的所有变量(包括返回的表本身)应当用local修饰.这样执行过模块加载过程后不会污染当前的变量名称(不会无意中改变同名变量的值).但是如果这样做,仅仅执行require而不把其返回值赋予变量,就无法用和模块名相同的名称访问这个表(这点和标准库中的模块不同).

因此为了避免一系列问题,模块的引用应当写成这样的形式:

>```lua
>packagename=require('packagename')
>```

一般来说标准库是自动require的.但是为了可读性,应当显式写出.

### 4. 复习函数

这里复习几点函数有关的知识.

任何函数都是要先定义后使用的。我们从来没有定义过print函数但是却可以直接使用print函数。这是因为Lua虚拟机自动为我们定义了这个函数。这类函数称为预定义函数。

预定义函数一部分是以模块的形式给出.一部分作为启动Lua自带的环境变量而存在(例如print,next等).在定义我们自己的变量时应当尽量避免和这些函数名,模块名重复.

如果函数定义中忘记了写return语句.函数会默认返回nil.但是如果模块脚本中忘记了写return语句,并且模块脚本可以正常运行,require函数会返回true.

## 后续推荐

* 0X32模块搜寻