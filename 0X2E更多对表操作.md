# 0X2E更多对表操作

## 前置知识

* 0X2D对表操作

## 正文

1. table.concat用于,将表的内容转化为字符串.
    * 最简单的调用形式是table.concat(list).list是个顺序列表.
    * 字符串参数sep作为分隔符.例如希望表的元素与元素在输出的字符串之间用逗号隔开就用:
        >```lua
        >table.concat(list,',')
        >```
    * 这个函数还可以追加两个整数参数,用于指定列表中的一个闭区间,把这个闭区间中的内容转化为字符串.例如:
        >```lua
        >table.concat(list,',',1,#list)
        >```
    * 如果没有指定闭区间,则默认把整个顺序列表转化为字符串返回.
1. table.move (a1, f, e, t ,a2)用于复制列表.
    * 参数a1,a2是两个顺序列表
    * 参数a2如果不给出,则默认为a1.
    * 参数f,e,t是整数.
    * 这个函数用于把a1中索引在f到e之间(包含f和e)的所有成员复制到a2中.
    * 复制到a2中的成员以t为起始位置.
    * 这个函数会返回a2.但即使不保存返回值,a2中的元素也经过了改动.
1. table.sort可以把顺序列表中的元素排序.这个函数会直接修改作为参数列表中的表,而其返回值一般没什么用.
    * table.sort(list)会把表中的元素从从小到大排列(改变值和索引之间的对应).
    * 这个函数排序的结果是这样得出的:把表中元素两两比较,如果a小于b`(a<b)`为真则a排在前边,否则b在前.
    * 字符串等值也是可以进行比较的.例如
        >```lua
        > 'abc'<'b'
        >```
    * 字符串比较的结果是按顺序逐个比较字符串中字符的ASCII码值大小得出的.如果一个字符串与另一个字符串的开头部分完全相同.则长的字符串比较大.
    * 实际上,Lua中的比较运算符也可以作用于数字以外的各种值.只要在元表中定义了其行为.这部分内容留到后续介绍.
    * 如果你已经了解过Lua中可以把函数作为参数传递.那么你还需要table.sort的另一个参数的作用.先给出例程:
        >```lua1
        >function co(x,y) return x>=y end
        >table.sort(list,co)
        >```
    * 传入table.sort的参数co应该是一个接受两个参数,返回一个逻辑值的函数.当它被传入时,将不再按照小于运算的判断结果排序.而是把列表中的元素两两传入函数co.视其返回值排序.如果co(a,b)返回值为true,则a在前,否则b在前.
    * 另外,co函数所定义的必须是严格的偏序关系.不具有对称性,但是具有传递性.
    * 如果列表中还有在定义的关系中相等的元素.那么它们之间的先后关系是不确定的.
1. 最后有一个类似操作表但实际上是操作函数列表的select.
    * 这个函数是基本函数.不需要table前缀.
    * 这个函数接受至少一个参数.第一个参数index是一个整数.
    * 在第一个参数之后的若干个参数(注意不是表)被当成一个序列处理.
    * 如果index是一个正整数则返回序列中的前index项.
    * 如果index是一个负整数则返回序列中的后index的绝对值项. 
    * select函数嵌套使用可以完成截取一个序列中的中间几项之类的复杂操作.
    * 如果想把一个表拆开为若干项作为select的输入,需要借助table.unpack函数.
    * 如果想把select的返回值打包成一个列表需要使用table.pack函数或者用花括号把select函数的调用表达式括起来.例如:
        >```lua
        >a={select(2,'aaa','bbb','ccc','ddd')}
        >```
    * select函数的第一个参数不可以是0但是可以是字符串'#'.如果是井号,则这个函数会返回除了第一个参数外的参数列表中的元素个数.

## 后续推荐

* 0X2F函数和表